# 패키지 구성 리뷰 (2024-06-13)

## 1. 현재 패키지 구조

```
jco.jcosaprfclink
├── config
├── controller
├── domain
├── dto
├── exception
├── repository
├── service
├── type
├── utils
└── JCoSapRfcLinkApplication.java (메인 실행 파일)
```

- **config**: 설정 관련 클래스
- **controller**: API 엔드포인트, 요청/응답 처리
- **domain**: 핵심 비즈니스 도메인(엔티티 등)
- **dto**: 데이터 전송 객체
- **exception**: 예외 처리
- **repository**: 데이터 접근 계층
- **service**: 비즈니스 로직
- **type**: Enum 등 타입 정의
- **utils**: 유틸리티 클래스

---

## 2. 1차 리뷰 및 개선 방향 제안

### 2.1 패키지 네이밍
- 현재 네이밍은 표준(Spring) 관례에 맞게 잘 되어 있음.
- 도메인 중심 설계(DDD) 적용 시, domain 하위에 aggregate별로 패키지 분리 가능.

### 2.2 SOLID 원칙 적용 관점
- 각 패키지가 명확한 책임을 가지도록 분리되어 있음(단일 책임 원칙).
- controller/service/repository 계층 분리는 개방-폐쇄 원칙, 의존성 역전 원칙 적용에 유리함.
- utils 패키지는 남용 시 단일 책임 원칙 위반 소지가 있으니, 꼭 필요한 공통 기능만 최소화해서 유지 권장.

### 2.3 확장성/유지보수성
- dto, exception, type 등은 계층 간 의존성을 낮추는 데 도움이 됨.
- config 패키지는 설정 클래스를 분리해 관리하므로, 환경별 설정 확장에 유리함.

---

## 3. 다음 단계 제안
1. 각 패키지(예: controller, service 등) 내부에 어떤 클래스들이 있는지 확인하면, 더 구체적으로 SOLID 원칙 위반 여부나 개선 포인트 안내 가능.
2. 우선 controller 패키지 내부 파일 목록을 확인 후, controller → service → repository 순으로 점검 추천.

> 원하시는 순서나 궁금한 패키지가 있다면 말씀해 주세요! 차근차근 리뷰해드리겠습니다. 

---

## 4. config.saprfc.SapRFCConnection.java 리뷰 및 개선

### 4.1 코드 분석
- **역할**: 애플리케이션 시작 시 RFC 서버를 구동하는 초기화 역할
- **구성**: @Component로 빈 등록, @Autowired로 JCoConnectionManager 주입, @PostConstruct로 서버 구동 메서드 실행

### 4.2 장점
- Spring의 라이프사이클(@PostConstruct)과 의존성 주입을 잘 활용
- 로그로 서버 시작 시점 명확히 표시

### 4.3 개선 포인트
- **의존성 주입 방식**: 생성자 주입 방식 권장(@Autowired 대신)
- **단일 책임 원칙**: 현재는 단일 책임(서버 구동)만 담당하므로 적절함
- **예외 처리**: 서버 구동 실패 시 예외 처리 및 로그 보완 필요
- **Bean 네이밍**: 특별한 네이밍 필요 시 @Component("beanName") 사용 가능

### 4.4 개선 예시

```java
@Slf4j
@Component
public class SapRFCConnection {
    private final JCoConnectionManager connManager;

    public SapRFCConnection(JCoConnectionManager connManager) {
        this.connManager = connManager;
    }

    @PostConstruct
    public void init() {
        try {
            log.info("RFC Server Start");
            connManager.stepRfcServer();
        } catch (Exception e) {
            log.error("RFC Server Start 실패", e);
            // 필요시 예외 재던지기 또는 알림 처리
        }
    }
}
``` 

---

## 5. config.saprfc.JCoConnectionManager.java 리뷰 및 개선 제안

### 5.1 문제점 요약
- **단일 책임 원칙 위반**: SAP 연결 설정, 서버 구동, 데이터 변환, 컨트롤러 Bean 등록 등 여러 역할이 한 클래스에 집중되어 있음
- **Bean 등록 방식 문제**: TaxInvoiceStateController를 직접 new로 생성해서 @Bean으로 등록 → Spring의 의존성 주입이 깨짐(실제 DI가 안 됨)
- **확장성/테스트 용이성 저하**: 모든 설정값을 @Value로 필드에 주입 → 생성자 주입 방식이 더 테스트와 유지보수에 유리

### 5.2 개선 방향
- **역할별로 클래스를 분리**
  - SAP 연결 설정: SAPConnectionProperties (설정값만 관리)
  - SAP 서버 구동: SAPServerManager (서버 구동/재시도/핸들러 등록)
  - 데이터 변환: SAPDataMapper (import/export 변환)
  - JCoConnectionManager: 위의 컴포넌트들을 조합해서 관리
- **의존성 주입 방식 통일**: @Value → 생성자 주입 방식으로 변경
- **불필요한 @Bean 등록 삭제**

### 5.3 예시 구조 (간단화)

#### SAPConnectionProperties.java
```java
@Component
@ConfigurationProperties(prefix = "sap.connect")
@Getter
public class SAPConnectionProperties {
    private String host;
    private String sysnr;
    private String client;
    private String user;
    private String passwd;
    private String lang;
}
```

#### SAPServerProperties.java
```java
@Component
@ConfigurationProperties(prefix = "jco.server")
@Getter
public class SAPServerProperties {
    private String connectionCount;
    private String threadCount;
    private String progid;
    private String repoDestination;
    private String gwserv;
    private String gwhost;
}
```

#### SAPServerManager.java
```java
@Slf4j
@Component
@RequiredArgsConstructor
public class SAPServerManager {
    private final SAPServerProperties serverProps;
    private final TaxInvoiceStateController handler;
    public void startServer() {
        // 서버 구동 및 핸들러 등록 로직만 담당
    }
}
```

#### SAPDataMapper.java
```java
@Component
public class SAPDataMapper {
    // setRFCImport, setRFCExport 등 데이터 변환만 담당
}
```

#### JCoConnectionManager.java
```java
@Component
@RequiredArgsConstructor
public class JCoConnectionManager {
    private final SAPConnectionProperties sapProps;
    private final SAPServerManager serverManager;
    private final SAPDataMapper dataMapper;
    @PostConstruct
    public void init() {
        // 설정 파일 생성, 서버 구동 등 조합
        serverManager.startServer();
    }
}
```

### 5.4 결론
- 지금 구조는 "작동은 하지만, 유지보수/확장/테스트"에 불리함
- 위와 같이 역할별로 클래스를 분리하면 각 역할이 명확해지고 테스트/확장/설정 관리가 쉬워짐 

---

## 6. 쓰레드/프로세스 관리 개선 방향 및 예시

### 6.1 현 구조의 한계
- JCo 서버의 worker/thread 설정은 단순 프로퍼티 관리에 그침
- Spring/SAP JCo의 기본 쓰레드풀 외에 별도의 비동기 작업, 장애 복구 등은 직접 관리하지 않음
- 서버 다운/쓰레드 고갈 시 자동 복구/모니터링이 어려움

### 6.2 개선 방향
- JCo 서버의 쓰레드/커넥션 설정값을 외부화 및 동적 관리
- Spring의 비동기(@Async), 스케줄링(@Scheduled), TaskExecutor 등 활용
- 커스텀 ThreadPoolTaskExecutor 도입으로 큐, 최대/최소 쓰레드, 거부 정책 등 세밀하게 관리
- Spring Actuator, Prometheus 등으로 모니터링 및 장애 복구 로직 추가

### 6.3 예시 코드

#### 1) Spring ThreadPoolTaskExecutor 설정
```java
@Configuration
public class AsyncConfig {
    @Bean("customTaskExecutor")
    public ThreadPoolTaskExecutor customTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(50);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("CustomAsync-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}
```

#### 2) 비동기 서비스 적용
```java
@Service
public class SomeAsyncService {
    @Async("customTaskExecutor")
    public void doAsyncTask() {
        // 비동기 처리 로직
    }
}
```

#### 3) JCo 서버 재시작/모니터링 로직 예시
```java
// SAPServerManager 내부
public void startServer() {
    // ... 기존 코드 ...
    if (서버가 다운되거나 예외 발생) {
        // 재시도/알림/모니터링 로직 추가
    }
}
```

### 6.4 결론 및 추천
- JCo 서버의 worker/thread 설정은 프로퍼티로 외부화하고, Spring의 TaskExecutor 등과 분리해서 관리
- 대량 작업/비동기 처리는 Spring의 @Async, TaskExecutor로 분리
- 모니터링/장애 복구는 Spring Actuator, 외부 모니터링 도구, 서버 재시작 로직 등으로 보완 

---

## 7. 최근 발생 문제 및 해결 방안

### 7.1 순환 참조(Circular Dependency) 문제

#### 문제 상황
```
JCoConnectionManager → SAPServerManager → TaxInvoiceStateController → JCoConnectionManager
```
- Bean 간 순환 참조로 인한 애플리케이션 기동 실패
- 각 컴포넌트가 서로를 참조하는 순환 구조 발생

#### 해결 방안
1. **의존성 구조 재설계**
   - JCoConnectionManager에서 SAPServerManager 의존성 제거
   - 서버 시작 로직을 SapRFCConnection으로 완전히 이전
   - TaxInvoiceStateController에서 JCoConnectionManager 의존성 제거

2. **책임 분리**
   - JCoConnectionManager: 설정 파일 생성만 담당
   - SapRFCConnection: 서버 시작 담당
   - SAPDataMapper: 데이터 변환 담당

### 7.2 설정 바인딩 문제

#### 문제 상황
- @ConfigurationProperties 바인딩 실패
- NullPointerException 발생
- 설정 키 네이밍 불일치

#### 해결 방안
1. **@Setter 추가**
   ```java
   @Getter
   @Setter
   @Component
   @ConfigurationProperties(prefix = "sap.connect")
   public class SAPConnectionProperties {
       private String host;
       private String sysnr;
       // ...
   }
   ```

2. **설정 키 네이밍 컨벤션 통일**
   ```yaml
   # 변경 전
   jco:
     server:
       connection_count: 2
       thread_count: 5
       repository_destination: ABAP_AS_WITHOUT_POOL

   # 변경 후
   jco:
     server:
       connectionCount: 2
       threadCount: 5
       repoDestination: ABAP_AS_WITHOUT_POOL
   ```

### 7.3 개선 효과
- **안정성 향상**: 순환 참조 제거로 애플리케이션 기동 안정화
- **유지보수성 향상**: 명확한 책임 분리로 코드 이해도 증가
- **확장성 향상**: 설정 변경이 용이하고 새로운 기능 추가가 쉬워짐

### 7.4 추가 권장사항
1. **생성자 주입 방식 사용**
   - @Autowired 대신 생성자 주입 방식 사용
   - 컴파일 타임에 의존성 문제 발견 가능

2. **설정값 검증**
   - @Validated와 @Valid 사용하여 설정값 유효성 검증
   - 필수 설정값 누락 시 빠른 실패

3. **로깅 강화**
   - 설정 로드, 서버 시작/종료 등 중요 이벤트 로깅
   - 문제 발생 시 원인 파악 용이 

---

## 8. utils 패키지 분석 및 개선 방안

### 8.1 현재 구조
```
utils/
├── JsonPaserUtil.java (JSON 파싱/변환 유틸리티)
└── HttpUtil.java (HTTP 통신 유틸리티)
```

### 8.2 JsonPaserUtil.java 분석

#### 장점
- JSON 변환 기능이 잘 모듈화되어 있음
- Map, List, String 간의 변환 메서드 제공
- 로깅 처리 포함

#### 개선 필요 사항
1. **클래스명 오타 수정**
   - `JsonPaserUtil` → `JsonParserUtil`로 수정 필요

2. **예외 처리 강화**
   - 현재는 로그만 남기고 null 반환
   - 커스텀 예외 추가하여 상위에서 처리 가능하도록 개선

3. **성능 최적화**
   - ObjectMapper 인스턴스 재사용
   - 불필요한 중간 변환 제거

4. **타입 안전성 강화**
   - 제네릭 활용하여 타입 안전성 확보
   - Object 대신 구체적인 타입 사용

### 8.3 HttpUtil.java 분석

#### 장점
- HTTP 메서드별 처리 로직 통합
- 응답 코드별 예외 처리
- 로깅 처리 포함

#### 개선 필요 사항
1. **설정 분리**
   - 타임아웃, 인코딩 등 설정값 외부화
   - Connection Pool 도입 검토

2. **비동기 처리 지원**
   - CompletableFuture 활용한 비동기 요청 지원
   - 응답 처리 콜백 추가

3. **재시도 메커니즘**
   - 일시적 오류에 대한 재시도 로직 추가
   - Circuit Breaker 패턴 적용 검토

4. **보안 강화**
   - SSL/TLS 설정 추가
   - 인증 토큰 관리 개선

### 8.4 개선 제안

#### 1. JsonParserUtil 개선
```java
@Slf4j
public class JsonParserUtil {
    private static final ObjectMapper objectMapper = new ObjectMapper();
    
    public static <T> T parseJson(String json, Class<T> clazz) {
        try {
            return objectMapper.readValue(json, clazz);
        } catch (IOException e) {
            log.error("JSON 파싱 실패: {}", e.getMessage());
            throw new JsonParsingException("JSON 파싱 실패", e);
        }
    }
    
    // ... 기타 메서드들
}
```

#### 2. HttpUtil 개선
```java
@Slf4j
public class HttpUtil {
    private static final int TIMEOUT = 5000;
    private static final String CHARSET = "UTF-8";
    
    public static CompletableFuture<String> sendAsyncRequest(
            String apiUrl, 
            HttpMethod method, 
            String body, 
            String token) {
        return CompletableFuture.supplyAsync(() -> 
            sendHttpRequest(apiUrl, method, body, token));
    }
    
    // ... 기존 메서드들
}
```

### 8.5 추가 권장사항

1. **테스트 코드 작성**
   - 단위 테스트 추가
   - 모의 객체(Mock) 활용한 통합 테스트

2. **문서화 강화**
   - JavaDoc 보완
   - 사용 예제 추가

3. **모니터링 추가**
   - 성능 메트릭 수집
   - 오류 추적 강화

4. **의존성 최소화**
   - 불필요한 라이브러리 제거
   - 순수 Java 기능 활용 검토 

## 9. SAP 서버 관리 구조 개선 (SOLID 원칙 적용)

### 9.1 기존 구조의 문제점

#### 1) 단일 책임 원칙(SRP) 위반
```java
// 기존 JCoConnectionManager.java
@Component
public class JCoConnectionManager {
    private final SAPServerProperties serverProperties;
    private final TaxInvoiceStateController handler;
    private JCoServer server;
    
    // 서버 초기화, 설정 관리, 핸들러 등록 등 여러 책임을 한 클래스에서 처리
    public void init() { ... }
    public void stepRfcServer() { ... }
    public void registerFunctionHandler() { ... }
}
```

#### 2) 의존성 역전 원칙(DIP) 미준수
- 구체적인 JCo 구현에 직접 의존
- 테스트와 확장이 어려운 구조

#### 3) 인터페이스 분리 원칙(ISP) 미준수
- 모든 기능이 하나의 클래스에 집중
- 불필요한 의존성 발생

### 9.2 개선된 구조

#### 1) 인터페이스 분리
```java
// SAPServer.java - 서버 핵심 기능 정의
public interface SAPServer {
    void start();
    void stop();
    JCoServerState getState();
    void registerFunctionHandler(String functionName, SAPFunctionHandler handler);
    void removeFunctionHandler(String functionName);
    void handleTransaction(JCoServerContext context, String tid);
}

// SAPFunctionHandler.java - 함수 처리 인터페이스
public interface SAPFunctionHandler {
    void handle(JCoServerContext context);
    String getFunctionName();
}

// SAPServerEventListener.java - 이벤트 처리 인터페이스
public interface SAPServerEventListener {
    void onStateChanged(JCoServerState oldState, JCoServerState newState);
    void onTransactionStarted(JCoServerContext context, String tid);
    void onTransactionCompleted(JCoServerContext context, String tid);
    void onCallAborted(JCoServerContext context, String tid, JCoServerContext.AbortReason reason);
}
```

#### 2) 추상 클래스를 통한 공통 기능 제공
```java
// AbstractSAPFunctionHandler.java
public abstract class AbstractSAPFunctionHandler implements SAPFunctionHandler {
    @Override
    public void handle(JCoServerContext context) {
        try {
            validateContext(context);
            processFunction(context);
        } catch (Exception e) {
            handleError(context, e);
        }
    }
    
    protected abstract void processFunction(JCoServerContext context);
}
```

#### 3) 구체적인 구현체
```java
// JCoSAPServer.java
@Component
public class JCoSAPServer implements SAPServer {
    private final String programId;
    private JCoServer server;
    private final List<SAPServerEventListener> eventListeners = new ArrayList<>();
    
    // 인터페이스 구현 및 이벤트 처리
}

// SAPServerManager.java
@Component
public class SAPServerManager {
    private final SAPServer server;
    private final Map<String, SAPFunctionHandler> functionHandlers = new ConcurrentHashMap<>();
    
    // 서버 및 핸들러 관리
}
```

### 9.3 개선 효과

#### 1) 단일 책임 원칙(SRP) 준수
- 각 클래스가 하나의 책임만 가짐
  - `SAPServer`: 서버 핵심 기능
  - `SAPFunctionHandler`: 함수 처리
  - `SAPServerEventListener`: 이벤트 처리
  - `SAPServerManager`: 전체 관리

#### 2) 개방-폐쇄 원칙(OCP) 준수
- 새로운 기능 추가가 기존 코드 수정 없이 가능
  - 새로운 함수 핸들러: `AbstractSAPFunctionHandler` 상속
  - 새로운 이벤트 처리: `SAPServerEventListener` 구현
  - 새로운 서버 구현: `SAPServer` 인터페이스 구현

#### 3) 리스코프 치환 원칙(LSP) 준수
- 모든 구현체가 인터페이스 계약을 준수
- 상속 관계에서 다형성 보장

#### 4) 인터페이스 분리 원칙(ISP) 준수
- 작고 집중된 인터페이스로 분리
- 불필요한 의존성 제거

#### 5) 의존성 역전 원칙(DIP) 준수
- 구체적인 구현이 아닌 추상화에 의존
- 테스트와 확장이 용이한 구조

### 9.4 실제 사용 예시

```java
// 새로운 함수 핸들러 구현
public class TaxInvoiceStateHandler extends AbstractSAPFunctionHandler {
    @Override
    protected void processFunction(JCoServerContext context) {
        // 세금계산서 상태 처리 로직
    }
    
    @Override
    public String getFunctionName() {
        return "INVOICE_ISSUE_STATUS_FUN";
    }
}

// 이벤트 리스너 구현
public class LoggingEventListener implements SAPServerEventListener {
    @Override
    public void onStateChanged(JCoServerState oldState, JCoServerState newState) {
        log.info("서버 상태 변경: {} -> {}", oldState, newState);
    }
    // 다른 이벤트 메서드 구현...
}

// 설정 및 사용
@Configuration
public class SAPConfig {
    @Bean
    public SAPServer sapServer(SAPServerProperties properties) {
        return new JCoSAPServer(properties.getProgramId());
    }
    
    @Bean
    public SAPServerManager sapServerManager(SAPServer server) {
        SAPServerManager manager = new SAPServerManager(server);
        manager.registerFunctionHandler("INVOICE_ISSUE_STATUS_FUN", new TaxInvoiceStateHandler());
        manager.addEventListener(new LoggingEventListener());
        return manager;
    }
}
```

### 9.5 추가 개선 가능 사항

1. **예외 처리 강화**
   - 커스텀 예외 클래스 추가
   - 예외 처리 계층 구조화

2. **모니터링 및 로깅**
   - 상세한 로그 레벨 설정
   - 메트릭 수집 추가

3. **설정 관리**
   - 설정값 검증 로직 추가
   - 동적 설정 변경 지원

4. **테스트 용이성**
   - 단위 테스트 추가
   - 통합 테스트 시나리오 작성

## 10. 최근 코드 개선 사항

### 10.1 ResponseResult 개선

#### 1) 제네릭 타입 지원
```java
@Getter
@NoArgsConstructor
@AllArgsConstructor
public class ResponseResult<T> {
    private String message;
    private ErrorCode errorCode;
    private T data;

    public ResponseResult(String message, ErrorCode errorCode) {
        this.message = message;
        this.errorCode = errorCode;
        this.data = null;
    }
}
```

#### 2) 정적 팩토리 메서드 추가
```java
public static <T> ResponseResult<T> success() {
    ResponseResult<T> result = new ResponseResult<>();
    result.message = "처리 완료";
    result.errorCode = ErrorCode.SUCCESS;
    return result;
}

public static <T> ResponseResult<T> success(T data) {
    ResponseResult<T> result = new ResponseResult<>();
    result.message = "처리 완료";
    result.errorCode = ErrorCode.SUCCESS;
    result.data = data;
    return result;
}

public static <T> ResponseResult<T> error(String message, ErrorCode errorCode) {
    ResponseResult<T> result = new ResponseResult<>();
    result.message = message;
    result.errorCode = errorCode;
    return result;
}
```

### 10.2 TaxInvoiceStateController 개선

#### 1) RESTful API 엔드포인트 구현
```java
@RestController
@RequestMapping("/api/v1/tax-invoice")
public class TaxInvoiceStateController {
    @PostMapping("/state")
    public ResponseEntity<ResponseResult<Void>> updateTaxInvoiceState(
            @RequestBody List<Map<String, Object>> taxInvoiceStateList) {
        // 세금계산서 상태 업데이트
    }

    @GetMapping("/state/{invoiceId}")
    public ResponseEntity<ResponseResult<Map<String, Object>>> getTaxInvoiceState(
            @PathVariable String invoiceId) {
        // 세금계산서 상태 조회
    }
}
```

#### 2) 에러 처리 개선
- 구체적인 에러 메시지 제공
- ErrorCode 활용한 에러 응답 구조화
- 로깅 강화

### 10.3 SAPFunctionHandler 인터페이스 개선

#### 1) 메서드 시그니처 개선
```java
public interface SAPFunctionHandler {
    void handle(JCoServerContext context, JCoFunction function);
    String getFunctionName();
}
```

#### 2) AbstractSAPFunctionHandler 구현
```java
public abstract class AbstractSAPFunctionHandler implements SAPFunctionHandler {
    @Override
    public void handle(JCoServerContext context, JCoFunction function) {
        try {
            validateContext(context);
            processFunction(context, function);
        } catch (Exception e) {
            handleError(context, function, e);
        }
    }

    protected abstract void processFunction(JCoServerContext context, JCoFunction function);
}
```

### 10.4 개선 효과

1. **타입 안전성 강화**
   - 제네릭을 통한 타입 체크
   - 컴파일 타임 에러 감지

2. **에러 처리 표준화**
   - 일관된 에러 응답 형식
   - 상세한 에러 메시지

3. **코드 재사용성 향상**
   - 정적 팩토리 메서드 활용
   - 추상 클래스를 통한 공통 기능 제공

4. **유지보수성 개선**
   - 명확한 책임 분리
   - 일관된 코딩 스타일

### 10.5 추가 개선 가능 사항

1. **API 문서화**
   - Swagger/OpenAPI 적용
   - API 버전 관리

2. **테스트 코드 보강**
   - 단위 테스트 추가
   - 통합 테스트 시나리오 작성

3. **성능 모니터링**
   - AOP를 통한 성능 측정
   - 메트릭 수집

4. **보안 강화**
   - 인증/인가 처리
   - 입력값 검증 

## [실제 인터페이스 예시] SAPServerEventListener.java

```java
package jco.jcosaprfclink.config.saprfc.interfaces;

import com.sap.conn.jco.server.JCoServerContext;
import com.sap.conn.jco.server.JCoServerState;

/**
 * SAP 서버 이벤트 리스너 인터페이스
 */
public interface SAPServerEventListener {
    /**
     * 서버 상태 변경 이벤트 처리
     * @param oldState 이전 상태
     * @param newState 새로운 상태
     */
    void onStateChanged(JCoServerState oldState, JCoServerState newState);

    /**
     * 트랜잭션 시작 이벤트 처리
     * @param context 서버 컨텍스트
     * @param tid 트랜잭션 ID
     */
    void onTransactionStarted(JCoServerContext context, String tid);

    /**
     * 트랜잭션 완료 이벤트 처리
     * @param context 서버 컨텍스트
     * @param tid 트랜잭션 ID
     */
    void onTransactionCompleted(JCoServerContext context, String tid);

    /**
     * 호출 중단 이벤트 처리
     * @param context 서버 컨텍스트
     * @param tid 트랜잭션 ID
     * @param reason 중단 사유
     */
    void onCallAborted(JCoServerContext context, String tid, JCoServerContext.AbortReason reason);
} 

- SAP 서버의 상태 변화, 트랜잭션 시작/완료, 호출 중단 등 주요 이벤트를 세분화하여 처리할 수 있도록 설계된 인터페이스입니다.
- 각 이벤트별로 별도의 메서드를 제공하여, 필요에 따라 로깅, 모니터링, 장애 대응 등 다양한 확장 구현이 가능합니다. 